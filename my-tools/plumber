#!/usr/bin/env python
# _*_ coding: utf-8 _*_

# pip install ruamel.yaml
import ruamel.yaml

from lib.utils import *

CACHE_ROOT = "/tmp/plumber"
RESOURCE_YAML_PATH = os.path.join(CACHE_ROOT, "plumber-resources.yml")
CACHE_RESOURCES = os.path.join(CACHE_ROOT, "resources")

if not os.path.exists(CACHE_RESOURCES):
    os.makedirs(CACHE_RESOURCES)

SUPPORT_TYPES = ["gcs", "s3", "git", "lftp", "pivnet", "artifactory", "github-release"]

yaml = ruamel.yaml.YAML()
yaml.indent(mapping=2, sequence=4, offset=2)
yaml.preserve_quotes = True


def my_options(parser):
    parser.add_option('-c', '--task-config',
                      type="string",
                      dest="task_config",
                      help=u"必填, Concourse task yaml配置文件的路径")

    parser.add_option('-p', '--pipeline-config',
                      type="string",
                      dest="pipeline_config",
                      help=u"必填, Concourse pipeline yaml配置文件的路径")

    parser.add_option('-f', '--force',
                      action="store_true",
                      dest="force",
                      default=False,
                      help=u"强制更新本地缓存资源, 如果已存在, 会先删除")

    parser.add_option('-s', '--sync',
                      action="store_true",
                      dest="sync",
                      default=False,
                      help=u"同步资源到本地, 一般初始化时会用到")

    parser.add_option('-e', '--piper-args',
                      type="string",
                      dest="piper_args",
                      default="",
                      help=u"透传给piper的参数")

    parser.add_option('-m', '--loadmaster-args',
                      type="string",
                      dest="loadmaster_args",
                      default="",
                      help=u"透传给loadmaster的参数")


def find_resources(config, res_type="inputs"):
    with open(config) as f:
        items = yaml.load(f)[res_type]

        if res_type == 'resources':
            resources = [item for item in items if item['type'].lower() in SUPPORT_TYPES]

            res_types_file_path = os.path.expanduser('~/.concourse-types.yml')
            with open(res_types_file_path, 'r') as res_types_file:
                resource_types = yaml.load(res_types_file)

            with open(RESOURCE_YAML_PATH, 'w+') as res_file:
                data = {
                    "resources": resources,
                    "resource_types": resource_types
                }
                yaml.dump(data, res_file)

            return [resource['name'] for resource in resources]

        return [item['name'] for item in items]


if __name__ == '__main__':
    (options, args), parser = parse_options('Wrapper for piper and loadmaster',
                                            my_options,
                                            usage=u"usage: %prog [options] <work_repo>")

    options.task_config = os.path.abspath(options.task_config)
    print "task yaml:\n\n\t", options.task_config

    options.pipeline_config = os.path.abspath(options.pipeline_config)
    print "\npipeline yaml:\n\n\t", options.pipeline_config

    required_options = "task_config pipeline_config".split()

    for r in required_options:
        if options.__dict__[r] is None:
            parser.error("parameter %s required" % r)

    if options.force:
        cmd = "rm -rf %s/*" % CACHE_RESOURCES
        print u"\n开始强制清理缓存: ", cmd
        os.system(cmd)

    inputs = find_resources(options.task_config)
    print "\n\n=== inputs ==="
    print "\t\n".join(inputs)

    outputs = find_resources(options.task_config, res_type="outputs")
    for output_dir in outputs:
        output_dir_path = os.path.join(CACHE_RESOURCES, output_dir)

        if not os.path.exists(output_dir_path):
            os.makedirs(output_dir_path)

    print "\n\n=== outputs ==="
    print "\t\n".join(outputs)
    print "\n"

    all_resources = find_resources(options.pipeline_config, res_type="resources")

    # 现在已经生成了plumber-resources.yml配置文件, 现在开始使用自己的配置文件
    options.pipeline_config = RESOURCE_YAML_PATH

    if not options.loadmaster_args:
        not_found_resources = []
        for task_input in inputs:
            if task_input not in all_resources:
                not_found_resources.append(task_input)

        if not_found_resources:
            print u"以下资源在pipeline yaml中无法找到, 或者已经重新映射! \n请适用正确资源名称重新指定: -m '-i <name1> -i <name2> ...'\n\t%s" % \
                  "\n\t".join(not_found_resources)
            exit(1)

    for task_input in inputs:
        if task_input in all_resources:
            options.loadmaster_args += " -i %s" % task_input

    cmd = "cd %s; cat '%s' | loadmaster %s" % (CACHE_RESOURCES, options.pipeline_config, options.loadmaster_args)
    print "loadmaster将要执行:"
    print "\t%s\n" % cmd
    print os.system(cmd)

    cmd = "piper -c %s %s" % (options.task_config, options.piper_args)
